#include <geometry_msgs/Twist.h>
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <ros/ros.h>
#include <cv_bridge/cv_bridge.h>
#include <pcl_ros/point_cloud.h>
#include <sensor_msgs/PointCloud2.h>
#include <opencv2/imgproc/imgproc.hpp>
#include <sensor_msgs/image_encodings.h>
#include <pcl_conversions/pcl_conversions.h>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl/filters/voxel_grid.h>
#include <opencv2/imgproc/imgproc.hpp> 

using namespace std;
void processCloud( const sensor_msgs::ImageConstPtr & msg ) {
  //ROS_INFO("I heard: [%s]", cloud->data.c_str());
  ROS_INFO("I am inside");
  //std::cout << "Received cloud msg: " << "header=" << msg->header << "width="<<msg->width <<", height="<<msg->height<<".\n";

  cv_bridge::CvImageConstPtr ptr = cv_bridge::toCvShare(msg);
		if(msg->encoding.compare(sensor_msgs::image_encodings::BGR8) == 0)
		{
			cv::Mat cpy = ptr->image.clone();
		}
		else if(msg->encoding.compare(sensor_msgs::image_encodings::RGB8) == 0)
		{
			cv::Mat bgr;
			cv::cvtColor(ptr->image, bgr, cv::COLOR_RGB2BGR);
		}
		else
		{
			ROS_ERROR("find_object_ros: Encoding \"%s\" detected. Supported image encodings are bgr8 and rgb8...", msg->encoding.c_str());
		}
}

int main(int argc, char **argv){

	ros::init(argc, argv, "ball_tracker");

	ros::NodeHandle n;

	ros::Subscriber sub = n.subscribe<sensor_msgs::PointCloud2>("/camera/depth/points", 1, processCloud);

	ros::spin();

    return 0;
}
